#include "stm32f10x.h"

void RTC_Config(void)
{
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure one bit for preemption priority */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

	/* Enable the RTC Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);

	PWR_BackupAccessCmd(ENABLE);
	RCC_LSEConfig(RCC_LSE_ON);
	while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);
	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
	RCC_RTCCLKCmd(ENABLE);

	RTC_WaitForSynchro();
	RTC_WaitForLastTask();
	RTC_ITConfig(RTC_IT_SEC, ENABLE);
	RTC_WaitForLastTask();
	RTC_SetPrescaler(31); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
	RTC_WaitForLastTask();
}

void RTC_IRQHandler(void)
{
	if (RTC_GetITStatus(RTC_IT_SEC) != RESET)
	{
		RTC_ClearITPendingBit(RTC_IT_SEC);
		RTC_WaitForLastTask();
	}
}


void _delay_ms(u32 msec)
{
	SysTick->LOAD  = ((SystemCoreClock/1000) & SysTick_LOAD_RELOAD_Msk) - 1;
	SysTick->VAL   = 0;
	SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	while(msec>0) if (SysTick->CTRL&SysTick_CTRL_COUNTFLAG_Msk) msec--;
	SysTick->VAL   = SysTick->CTRL  = 0;
}

void _delay_us(u32 usec)
{
	SysTick->LOAD  = ((SystemCoreClock/1000000) & SysTick_LOAD_RELOAD_Msk) - 1;
	SysTick->VAL   = 0;
	SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	while(usec>0) if (SysTick->CTRL&SysTick_CTRL_COUNTFLAG_Msk) usec--;
	SysTick->VAL   = SysTick->CTRL  = 0;
}

void _delay(u32 usec)
{
	uint32_t count = 0;
	const uint32_t utime = (120 * usec / 7);
	do
	{
		if ( ++count > utime )
		{
		  return;
		}
	}
	while (1);
}

typedef struct
{
  uint16_t Pin;
  GPIO_TypeDef *Port;
}
GPIO_Def;

GPIO_Def pins[36];

void psetup()
{
	int i;
	for(i=0;i<36;i++)
	{
		pins[i].Pin = 0;
		pins[i].Port = 0;
	}
}

void pmap(uint16_t id, GPIO_TypeDef *port, uint16_t pin)
{
	pins[id].Pin = 1<<pin;
	pins[id].Port = port;
}

void pinit(uint16_t id, GPIOSpeed_TypeDef speed, GPIOMode_TypeDef mode)
{
	if (pins[id].Port != 0 && pins[id].Pin != 0)
	{
		GPIO_InitTypeDef portInit;
		portInit.GPIO_Speed = speed;
		portInit.GPIO_Mode  = mode;
		portInit.GPIO_Pin   = pins[id].Pin;
		GPIO_Init(pins[id].Port, &portInit);
	}
}

void pset(uint16_t id, uint8_t state)
{
	if (state != Bit_RESET)
	{
		pins[id].Port->BSRR = pins[id].Pin;
	}
	else
	{
		pins[id].Port->BRR = pins[id].Pin;
	}
}


int main(void)
{
	RCC_ClocksTypeDef RCC_ClockFreq;
	RCC_GetClocksFreq(&RCC_ClockFreq);

	RTC_Config();

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);

	//TIM4
	pmap( 0, GPIOB,  9);
	pmap( 1, GPIOB,  8);
	pmap( 2, GPIOB,  7);
	pmap( 3, GPIOB,  6);
	//TIM1
	pmap( 4, GPIOA, 11);
	pmap( 5, GPIOA, 10);
	pmap( 6, GPIOA,  9);
	pmap( 7, GPIOA,  8);
	//TIM8
	pmap( 8, GPIOC,  9);
	pmap( 9, GPIOC,  8);
	pmap(10, GPIOC,  7);
	pmap(11, GPIOC,  6);
	//TIM12
	pmap(12, GPIOB, 15);
	pmap(13, GPIOB, 14);
	//TIM3
	pmap(14, GPIOB,  1);
	pmap(15, GPIOB,  0);
	pmap(16, GPIOA,  7);
	pmap(17, GPIOA,  6);
	//TIM2
	pmap(18, GPIOA,  3);
	pmap(19, GPIOA,  2);
	pmap(20, GPIOA,  1);
	pmap(21, GPIOA,  0);

	//I2C (DA,CL)
	pmap(22, GPIOB,  11);
	pmap(23, GPIOB,  10);

	//USART4,5 (TX,RX)
	pmap(24, GPIOC,  10);
	pmap(25, GPIOC,  11);
	pmap(26, GPIOC,  12);
	pmap(27, GPIOD,   2);

	//PORT
	pmap(28, GPIOC,  3);
	pmap(29, GPIOC,  2);
	pmap(30, GPIOC,  1);
	pmap(31, GPIOC,  0);

	//SPI (CS,CK,MISO,MOSI)
	pmap(32, GPIOA, 15);
	pmap(33, GPIOB,  3);
	pmap(34, GPIOB,  4);
	pmap(35, GPIOB,  5);

	int i=0;
	for(i=0;i<36;i++)
	{
		pinit(i, GPIO_Speed_50MHz, GPIO_Mode_Out_PP);
		pset(i, 0);
	}

	i=0;
	int last = RTC_GetCounter();
	while(1)
    {
		int cur = RTC_GetCounter();
		if (cur != last)
		{
			pset(0, (i++)%2==0);
			last = cur;
		}
    }
}





	RCC_ADCCLKConfig (RCC_PCLK2_Div6);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	ADC_InitTypeDef ADC_InitStructure;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AIN;
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0;
	GPIO_Init(GPIOC, &GPIO_InitStructure);


	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfChannel = 10;
	ADC_RegularChannelConfig(ADC1,ADC_Channel_10, 1, ADC_SampleTime_239Cycles5);
	ADC_Init(ADC1, &ADC_InitStructure);
	ADC_Cmd (ADC1,ENABLE);
	ADC_ResetCalibration(ADC1);	// Reset previous calibration
	while(ADC_GetResetCalibrationStatus(ADC1));
	ADC_StartCalibration(ADC1);	// Start new calibration (ADC must be off at that time)
	while(ADC_GetCalibrationStatus(ADC1));
	ADC_Cmd (ADC1,ENABLE);	//enable ADC1
	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	// start conversion (will be endless as we are in continuous mode)

	xxx = ADC_GetConversionValue(ADC1)